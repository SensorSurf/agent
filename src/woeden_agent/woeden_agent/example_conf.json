{"id": 13, "topic": "/health", "type": "std_msgs/msg/String", "comparison": {"field": "range", "value": "5.0", "comparator": "LESS_THAN", "value_type": "NUMBER"}, "enabled": true, "topics": [{"name": "/parameter_events", "type": "rcl_interfaces/msg/ParameterEvent", "frequency": 0, "max_frequency": true}], "duration": 0, "base_path": "/", "msgdef": "# generated from rosidl_generator_py/resource/_idl.py.em\n# with input from msgs:msg/Trigger13.idl\n# generated code does not contain a copyright notice\n\n\n# Import statements for member types\n\nimport builtins  # noqa: E402, I100\n\nimport rosidl_parser.definition  # noqa: E402, I100\n\n\nclass Metaclass_Trigger13(type):\n    \"\"\"Metaclass of message 'Trigger13'.\"\"\"\n\n    _CREATE_ROS_MESSAGE = None\n    _CONVERT_FROM_PY = None\n    _CONVERT_TO_PY = None\n    _DESTROY_ROS_MESSAGE = None\n    _TYPE_SUPPORT = None\n\n    __constants = {\n    }\n\n    @classmethod\n    def __import_type_support__(cls):\n        try:\n            from rosidl_generator_py import import_type_support\n            module = import_type_support('msgs')\n        except ImportError:\n            import logging\n            import traceback\n            logger = logging.getLogger(\n                'msgs.msg.Trigger13')\n            logger.debug(\n                'Failed to import needed modules for type support:\\n' +\n                traceback.format_exc())\n        else:\n            cls._CREATE_ROS_MESSAGE = module.create_ros_message_msg__msg__trigger13\n            cls._CONVERT_FROM_PY = module.convert_from_py_msg__msg__trigger13\n            cls._CONVERT_TO_PY = module.convert_to_py_msg__msg__trigger13\n            cls._TYPE_SUPPORT = module.type_support_msg__msg__trigger13\n            cls._DESTROY_ROS_MESSAGE = module.destroy_ros_message_msg__msg__trigger13\n\n    @classmethod\n    def __prepare__(cls, name, bases, **kwargs):\n        # list constant names here so that they appear in the help text of\n        # the message class under \"Data and other attributes defined here:\"\n        # as well as populate each message instance\n        return {\n        }\n\n\nclass Trigger13(metaclass=Metaclass_Trigger13):\n    \"\"\"Message class 'Trigger13'.\"\"\"\n\n    __slots__ = [\n        '_data',\n    ]\n\n    _fields_and_field_types = {\n        'data': 'string',\n    }\n\n    SLOT_TYPES = (\n        rosidl_parser.definition.UnboundedString(),  # noqa: E501\n    )\n\n    def __init__(self, **kwargs):\n        assert all('_' + key in self.__slots__ for key in kwargs.keys()), \\\n            'Invalid arguments passed to constructor: %s' % \\\n            ', '.join(sorted(k for k in kwargs.keys() if '_' + k not in self.__slots__))\n        self.data = kwargs.get('data', str())\n\n    def __repr__(self):\n        typename = self.__class__.__module__.split('.')\n        typename.pop()\n        typename.append(self.__class__.__name__)\n        args = []\n        for s, t in zip(self.__slots__, self.SLOT_TYPES):\n            field = getattr(self, s)\n            fieldstr = repr(field)\n            # We use Python array type for fields that can be directly stored\n            # in them, and \"normal\" sequences for everything else.  If it is\n            # a type that we store in an array, strip off the 'array' portion.\n            if (\n                isinstance(t, rosidl_parser.definition.AbstractSequence) and\n                isinstance(t.value_type, rosidl_parser.definition.BasicType) and\n                t.value_type.typename in ['float', 'double', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64']\n            ):\n                if len(field) == 0:\n                    fieldstr = '[]'\n                else:\n                    assert fieldstr.startswith('array(')\n                    prefix = \"array('X', \"\n                    suffix = ')'\n                    fieldstr = fieldstr[len(prefix):-len(suffix)]\n            args.append(s[1:] + '=' + fieldstr)\n        return '%s(%s)' % ('.'.join(typename), ', '.join(args))\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return False\n        if self.data != other.data:\n            return False\n        return True\n\n    @classmethod\n    def get_fields_and_field_types(cls):\n        from copy import copy\n        return copy(cls._fields_and_field_types)\n\n    @builtins.property\n    def data(self):\n        \"\"\"Message field 'data'.\"\"\"\n        return self._data\n\n    @data.setter\n    def data(self, value):\n        if __debug__:\n            assert \\\n                isinstance(value, str), \\\n                \"The 'data' field must be of type 'str'\"\n        self._data = value\n"}
